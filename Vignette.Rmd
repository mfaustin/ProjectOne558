---
title: "Pokemon API Vignette"
author: "Mark Austin"
date: "10/05/2021"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.path = "images/")
```

## Required R Packages 

The following R packages are required to run R code used in this Vignette and/or create this document.  

* `tidyverse`  The tidyverse package is used for data handling and plotting.  

* `jsonlite`  The jsonlite package is used to contact the API and return data.  

* `knitr`  The knitr package is used for document image handling.  

* `rmarkdown`  The rmarkdown package is used by a render program to render this document.  

```{r packages,message=FALSE,echo=FALSE}
   library(tidyverse)
   library(jsonlite)
   library(knitr)
```




## Pokemon API Query and Data Proccessing Functions 

I created the following functions to query and process data from the [Pokemon API](https://pokeapi.co/) using [Pokemon API Documentation](https://pokeapi.co/docs/v2).  I found that I could use `fromJSON()` directly with the Pokemon API and directly assign API calls.

### Pokemon Endpoint Functions.  

Most data relevant to individual pokemon is obtained from the [Pokemon endpoint](https://pokeapi.co/docs/v2#pokemon).  This endpoint returns a complex list of lists with more data than most users would need.  I've provided three functions to query and process pokemon endpoint data.  The functions all return data frames.  

1. `getPokeNameIDFunction`  In order to query individual pokemon, the user must provide either a name or id value.  This function returns a list of all possible pokemon for this endpoint so that the user will know what pokemon are available.  The names can be sorted as an option.


```{r getPokeNameIDFunction}
getPokeNameID <- function(sortName=FALSE){
  
  apiData<-fromJSON("https://pokeapi.co/api/v2/pokemon/?limit=1222")
  
  allNames<-as_tibble(apiData$results)
  
  allNames<-allNames %>% mutate(ID=as.numeric(basename(url)))
  
  if (sortName) {
    allNames<-allNames %>% arrange(name)
  }
  
  return(allNames)
  
}
```


Example `getPokeNameIDFunction` usage with output.  

```{r getPokeNameIDExample}
head(getPokeNameID(sortName = TRUE))
```


2. `getOnePokeData`  Given a pokemon name or id, this function returns a data frame with data for that pokemon.  Given how much data is available and the complexity of processing data, I give the user a few options for the amount of data returned.  The default option returns top level data including `species,height,weight,base_experience`.  Turning the basestat function additionally returns `hp,attack,defense,special_attack,special_defense ,speed`.  Finally, turning the type option on additionally returns primary and secondary types `type_one,type_two`.   



```{r getOnePokeData Function}

getOnePokeData<-function(pokemon,basestat=FALSE,type=FALSE){
  
  ##Get list of pokemon and process user pokemon input
  pokeNameID<-getPokeNameID()
  
  if (is.numeric(pokemon)){
    pokeNameID<-pokeNameID%>%filter(ID==pokemon)
  } else if (is.character(pokemon)){
    pokeNameID<-pokeNameID%>%filter(name==tolower(pokemon))
  } else {
    stop("Please enter either pokemon integer or quoated name value")
  }
  
  PokeList<- fromJSON(pokeNameID$url,flatten = TRUE)
  
  ###Function Default Data
  name<-PokeList$name
  height<-PokeList$height
  id<-PokeList$id
  species<-PokeList$species$name
  weight<-PokeList$weight
  base_experience<-PokeList$base_experience
  
  LocalDF<-data.frame(name,id,species,height,weight,base_experience)
  
  ##process and add base stat data if user selects basestat TRUE
  if (basestat){
    hp<-PokeList$stats$base_stat[1]
    attack<-PokeList$stats$base_stat[2]
    defense<-PokeList$stats$base_stat[3]
    special_attack<-PokeList$stats$base_stat[4]
    special_defense<-PokeList$stats$base_stat[5]
    speed<-PokeList$stats$base_stat[6]
    
    LocalDF<-LocalDF%>%mutate(hp,attack,defense,special_attack   ,special_defense ,speed)
  }
  
  ##process and add type data if user selects type TRUE
  if(type){
    ##All pokemon has at least one type so assign here
    type_one<-PokeList$types$type.name[1]
    
    ##check if more than one type and set 
    ##second type as needed
    if(length(PokeList$types$slot)>1){
      type_two<-PokeList$types$type.name[2]
    }else{
      type_two<-"None"
    }
    
    LocalDF<-LocalDF%>%mutate(type_one,type_two)
  }
  
  
  return(LocalDF)
  
}
```

Examples of ways to use `getOnePokeData`.  

```{r getOnePokeExample, eval=FALSE}
getOnePokeData("Venusaur")
getOnePokeData(pokemon=8,basestat = TRUE)
getOnePokeData(435,type = TRUE)
getOnePokeData(10032,basestat = TRUE,type = TRUE)
```


3. `getEveryPokeData`  This function returns data for ALL pokemon and returns one data frame.  The amount of data returned is dependent on the basetat and type options as described in `getOnePokeData`.  


```{r getEveryPokeData Function}
getEveryPokeData<-function(basestat=FALSE,type=FALSE){
  
  ###Get current number of pokemon to process
  #getPokeNameID
  pokeNameID<-getPokeNameID()
  idVals<-pokeNameID$ID
  
  ###Loop through every pokemon and build data frame
  ###by adding new rows
  ###Most of the time spent here is in the numerous 
  ###   calls to API address since there are so many pokemon
  allPoke<-data.frame()
  for (i in idVals) {
    allPoke<-rbind(allPoke,getOnePokeData(i,basestat,type))
  }
  
  return(allPoke)
}

```
Example of `getEveryPokeData` data frame data.  
```{r getEveryPokeData output,cache=TRUE}
everyPoke<-getEveryPokeData(basestat = TRUE,type = TRUE)
head(everyPoke)
```


### Species Endpoint Functions  

Most pokemon species map to one individual pokemon but there are some species that map to several indidual pokemon.  Collective species data is obtained from the [Pokemon Species endpoint](https://pokeapi.co/docs/v2#pokemon-species).  Because species data is less complex, I was able to return more default data from this endpoint than the pokemon endpoint.  I've provided three functions to query and process pokemon endpoint data.  The functions all return data frames.  


1. `getSpeciesNameID`  This function returns a data frame with a list of possible species names and id values so that the user will know what is available.  Optional sorting my name is provided.  

```{r getSpeciesNameID Function}
getSpeciesNameID <- function(sortName=FALSE){
  
  apiData<-fromJSON("https://pokeapi.co/api/v2/pokemon-species/?limit=1222")
  
  allNames<-as_tibble(apiData$results)
  
  allNames<-allNames %>% mutate(ID=as.numeric(basename(url)))
  
  if (sortName) {
    allNames<-allNames %>% arrange(name)
  }
  
  return(allNames)
  
}
```

2. `getOneSpeciesData`  Given species name or id this function returns a data frame for one species with the following data. `species,shape,generation,base_happiness,capture_rate,gender_rate,hatch_counter,is_baby,is_legendary,is_mythical`.  


```{r getOneSpeciesData Function}
getOneSpeciesData<-function(species){
   
   ##Get list of species and process user species input
   pokeSpeciesID<-getSpeciesNameID()
   
   if (is.numeric(species)){
     pokeSpeciesID<-pokeSpeciesID%>%filter(ID==species)
   } else if (is.character(species)){
     pokeSpeciesID<-pokeSpeciesID%>%filter(name==tolower(species))
   } else {
     stop("Please enter either species integer or quoated name value")
   }
   
   PokeList<- fromJSON(pokeSpeciesID$url,flatten = TRUE)
   
   ###Function Data to return
   species<-PokeList$name
   shape<-PokeList$shape$name
   generation<-PokeList$generation$name
   base_happiness<-PokeList$base_happiness
   capture_rate<-PokeList$capture_rate
   gender_rate<-PokeList$gender_rate
   hatch_counter<-PokeList$hatch_counter
   is_baby<-PokeList$is_baby
   is_legendary<-PokeList$is_legendary
   is_mythical<-PokeList$is_mythical

   
   LocalDF<-data.frame(species,shape,generation,base_happiness,  
            capture_rate,gender_rate,hatch_counter,  
            is_baby,is_legendary,is_mythical)
   

   
   return(LocalDF)
   
 }
 
```

3. `getEverySpeciesData`  This function returns data for every species as a data frame with optional sorting of the data based on the sortName option.  The following data is returned  
`species,shape,generation,base_happiness,capture_rate,gender_rate,hatch_counter,is_baby,is_legendary,is_mythical`.  

```{r getEverySpeciesData Function}
getEverySpeciesData<-function(sortName=FALSE){
   
   ###Get current number of species to process
   pokeSpeciesID<-getSpeciesNameID()
   idVals<-pokeSpeciesID$ID
   
   
   ###Loop through every species and build data frame
   ###by adding new rows
   ###Most of the time spent here is in the numerous 
   ###   calls to API address since there are so many species
   allPoke<-data.frame()
   for (i in idVals) {
     allPoke<-rbind(allPoke,getOneSpeciesData(i))
   }
   
   if (sortName) {
     allPoke<-allPoke %>% arrange(species)
   }
   
   return(allPoke)
 }
```

Example of `getEverySpeciesData` data frame data.  
```{r getEverySpeciesData output,cache=TRUE}
everyPokeSpecies<-getEverySpeciesData(sortName = TRUE)
head(everyPokeSpecies)
```


### Evolution Chain Endpoint Functions.  

Many pokemon can [evolve](https://pokemondb.net/evolution) into another more powerful pokemon.  Evolution chain data is obtained from the [Pokemon Evolution Chain Endpoint](https://pokeapi.co/docs/v2#evolution-chains).  This endpoint only takes ID and those IDs are linked to one part of a chain.

I've provided three functions to query and process pokemon evolution chain endpoint data.  The functions both return data frames.  



1. `getOneEvolveData`  This function takes an ID number for one of the chains and returns the chain data for that chain as data frame.  Each data frame row has a value for a chain level or None if that chain does not have all three stages.  

```{r getOneEvolveData Function}
getOneEvolveData<-function(ID){
  
  ###Construct URL from the given ID and call API
  basicURL<-"https://pokeapi.co/api/v2/evolution-chain/"
  queryURL<-paste0(basicURL,ID)
  queryResult<-fromJSON(queryURL)
  
  ###Parse results into stages or no evolve categories
  stageOne<-queryResult$chain$species$name
  stageTwo<-queryResult[["chain"]][["evolves_to"]][["species"]][["name"]]
  stageThree<-queryResult[["chain"]][["evolves_to"]][["evolves_to"]][[1]][["species"]][["name"]] 
  if (is.null(stageTwo)){
    stageTwo<-"None"
  }
  if (is.null(stageThree)){
    stageThree<-"None"
  }
  
  localDF<-data.frame(stageOne,stageTwo,stageThree)
  return(localDF)
}


```

An example of data frame returned from `getOneEvolveData`  
```{r getOneEvolveData Example}
  getOneEvolveData(57)
```



2. `getAllEvolveSeries`  This function returns a data frame of all the evolve stage items.  The function will optionally sort on the first stage value.  

```{r getAllEvolveSeries Function}
getAllEvolveSeries<-function(sortName=FALSE){
  
  metaEvolve<-fromJSON("https://pokeapi.co/api/v2/evolution-chain/?limit=600")
  
  metaEvolveDF<-as_tibble(metaEvolve$results)
  
  metaEvolveDF<-metaEvolveDF %>% mutate(ID=as.numeric(basename(url)))
  
  ##Loop through all the ID values and build a data frame
  ## for all the evolution chain data
  allEvolve<-data.frame()
  for (loopID in metaEvolveDF$ID) {
    allEvolve<-rbind(allEvolve,getOneEvolveData(loopID))
  } 
  
   if (sortName) {
     allEvolve<-allEvolve %>% arrange(stageOne)
   }
  
  return(allEvolve)
}

```



3. `getAllEvolveStages`  This function takes data parsed by chain and converts the data into a data frame containing species name and stage value for that species.  The function will optionally sort on species.  

```{r getAllEvolveStages Function,cache=TRUE}

getAllEvolveStages<-function(sortName=FALSE){
  
  resultsEvolve<-getAllEvolveSeries()
  
  ###Handles the first one which they all have
  ###Now can do stageTwo and three
  allEvolve<-data.frame()
  species<-resultsEvolve$stageOne
  stages<-ifelse(resultsEvolve$stageTwo=="None",stage<-"noEvolve",stage<-"one")
  stages
  allEvolve<-data.frame(species,stages)
  ###Need to use rbind to add other parts after this part
  species<-resultsEvolve$stageTwo
  stages<-ifelse(resultsEvolve$stageTwo=="None",stage<-"noEvolve",stage<-"two")
  twoEvolve<-data.frame(species,stages)
  twoEvolve<-twoEvolve %>% filter(species!="None")
  allEvolve<-rbind(allEvolve,twoEvolve)
  
  species<-resultsEvolve$stageThree
  stages<-ifelse(resultsEvolve$stageThree=="None",stage<-"noEvolve",stage<-"three")
  threeEvolve<-data.frame(species,stages)
  threeEvolve<-threeEvolve %>% filter(species!="None")
  allEvolve<-rbind(allEvolve,threeEvolve)
  ###Later use distinct function to remove duplicate rows
  allEvolve<-allEvolve %>% distinct(species,.keep_all = TRUE)
  
  allEvolve$stages<-as.factor(allEvolve$stages)
  allEvolve$stages<-ordered(allEvolve$stages,levels=c("one","two","three","noEvolve"))
  
  if (sortName) {
     allEvolve<-allEvolve %>% arrange(species)
   }
  
  return(allEvolve)
}


```

An example of output from `getAllEvolveStages`.  
```{r getAllEvolveStages Example,cache=TRUE}
  evolveStages<-getAllEvolveStages(sortName = TRUE)
  head(evolveStages)
```



## Exploratory Data Analysis  


### Get Full Data Frames  

I started by pulling data from the three endpoints I wrote functions for earlier.  I pull all the data here so that I'll have it stored in objects for later use.  

```{r getData, cache=TRUE}
allPoke<-getEveryPokeData(basestat = TRUE,type = TRUE)
allSpecies<-getEverySpeciesData()
allStages<-getAllEvolveStages()
```


### Creating New Variables  

In this section I create new variables that I plan to use in later analysis.  
First, I create a `totalPts` quantitative variable based on adding related point based variables.  In pokemon references different pokemon are often compared based on total points. Here is a reference showing total poins for one paritular pokemon  [Total Point Example](https://bulbapedia.bulbagarden.net/wiki/Kricketot_(Pok%C3%A9mon)#Base_stats)  

Second, I create a `hgtwgt_ratio` quantitative variable based on the basic height to weight raio.  This ratio is often used in biology.  

Third, I create a `common` categorical variable based on other species categorical variables.  I wanted every species to be in one `common` category that eventually will show whether the species is in one of the rare categories like legendary or mythical.   

```{r create new vars}
###total points
moreAllPoke<-allPoke %>% mutate(totalPts=(hp+attack+defense+special_attack   +special_defense +speed)) %>% select(name,id,species,height,weight,base_experience,totalPts,everything()) 

summary(moreAllPoke)

###height to weight ratio
moreAllPoke<-moreAllPoke %>%mutate(hgtwgt_ratio=height/weight)

###mythic,legendary, regular,baby
###Create new factor variable that assigns one of these values
moreAllSpecies<-allSpecies %>% 
  mutate(common=if_else(is_baby, "baby",
              if_else(is_mythical,"mythical",
                    if_else(is_legendary,"legendary","regular"))))

```



### Contingency Tables  

**Contingency Table One**  

Every individual pokemon  has one of 18 different [pokemon types](https://bulbapedia.bulbagarden.net/wiki/Type).  I created my first contingency table to examine how many pokemon were part of each type by the evolution stage for that pokemon.  I included non evolving pokemon because many pokemon do not evolve.  


```{r contingencytables}

###combine needed tables to get data together for table
combinePoke<-inner_join(moreAllPoke,allStages,by="species") %>% select(name,stages,everything())

###Create table then add margins to include sums
tOne<-table(combinePoke$type_one,combinePoke$stages )
kable(addmargins(tOne),caption = "Contingency Table of Type by Stage")

```

What stood out to me from the first table in regard to evolution stages was that there were many more first and second stage pokemon than third stage.  That outcome made sense because players go from lower to higher stages over time so fewer third stage were expected.  
As for pokemon types, I immediately notice there are very few flying types.  I also noticed water, normal, and grass were most numerous.  The other trend I saw was that each type tends to follow the overall pattern of more first and second stage pokemon.  

**Contingency Table Two**  

I learned [pokemon generations](https://bulbapedia.bulbagarden.net/wiki/Generation) are used to group pokemon over time with i being oldest and viii being most recent.  For the second table, I looked at generation versus what I called common status meaning whether a pokemon is regular or in rare category.  I added margin sums again to help spot patterns.  Note this data is from species data and there are fewer species than pokemon.  

```{r more contingency work}
tTwo<-table(moreAllSpecies$generation,moreAllSpecies$common)
kable(addmargins(tTwo),
      caption = "Contingency Table of Generation by Common Status")
```
<br>  
What stood out to me in the second table was there were more pokemon species created in the i to V earlier generations than the more recent generations.  In addition, I did confirm that the rare types are indeed rare with baby being especially uncommon.  

### Numerical Summaries  


**Capture Rate By Generation**  
I learned that [capture rate](https://bulbapedia.bulbagarden.net/wiki/Catch_rate) is a key value where higher numbers mean easier to catch.  I summarized by generation to see whether capture rate was changing over time.  


```{r capture rate by generation}
allSpecies %>% group_by(generation) %>% 
  summarise(Avg = mean(capture_rate), Sd = sd(capture_rate), 
    Median = median(capture_rate), IQR =IQR(capture_rate))
```

**Speed by Generation**  


```{r speed by generation}
##moreallpoke and species
comboSpeciesPoke<-inner_join(moreAllPoke,moreAllSpecies,by="species")
comboSpeciesPoke %>% group_by(generation) %>% 
  summarise(Avg = mean(speed), Sd = sd(speed), Median =       
              median(speed), IQR =IQR(speed))
```

**Total Points by Common Status**  

```{r total points by common status}
comboSpeciesPoke %>% group_by(common) %>% 
    summarise(Avg = mean(totalPts), Sd = sd(totalPts), Median =       
              median(totalPts), IQR =IQR(totalPts))
```



### Box Plot  

I was interested in investigating the relationship between pokemon total points and evolution stage in a box plot.  I needed to manually adjust the colors because the automatic colors were blending into the background.  


```{r Box Plot}

###Create a boxplot with added points for stage and total points  
g <- ggplot(combinePoke, aes(x = stages, y = totalPts))
g + geom_boxplot(fill="green1") + 
  geom_point((aes(color = stages)), size=1,position = "jitter",alpha = 0.1)    + labs(x="Evolution Stages", y="Total Points",
  title = "Boxplot of Total Points for Different Evolution Stages") + 
  scale_color_manual(values = c("red", "blue", "orangered","purple"),name =    "Evolution\nStages") 

```  
<br>  
The boxplot confirmed my expectation that total points would be higher for higher pokemon evolution stages.  This outcome makes sense because more evolved pokemon are more powerful and power is quantified by total points.  In addition, I could see that the no evolving pokemon are also mainly very powerful too.  

### Bar Plot  

```{r bar plot}

```

### Histogram  

```{r histogram}

```



### Scatter Plot  

```{r plotheightweight}
head(allPoke)
g<-ggplot(data = allPoke,aes(x=weight,y=height))
g+geom_point(aes(color=type_one))

```


### Fifth Plot  

```{r fifth plot}

```


```{r summarystats}
allPoke %>% group_by(type_one) %>% summarise(mweight=mean(weight),sdweight=sd(weight))
allPoke %>% summary()
summary(allPoke$weight)
cor(allPoke$hp,allPoke$weight)
cor(allPoke$height,allPoke$weight)
shortPoke<-allPoke %>% filter(height<500) 
cor(shortPoke$height,shortPoke$weight)

summary(shortPoke$height)

g<-ggplot(data = shortPoke,aes(x=weight,y=height))
g+geom_point(aes(color=type_one))

```


