---
title: "Pokemon API Vignette"
author: "Mark Austin"
date: "10/05/2021"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.path = "images/")
```

## Required R Packages 

The following R packages are required to run R code used in this Vignette and/or create this document.  

* `tidyverse`  The tidyverse package is used for data handling and plotting.  

* `jsonlite`  The jsonlite package is used to contact the API and return data.  

* `knitr`  The knitr package is used for document image handling.  

* `rmarkdown`  The rmarkdown package is used by a render program to render this document.  

```{r packages,message=FALSE,echo=FALSE}
   library(tidyverse)
   library(jsonlite)
   library(knitr)
```




## Pokemon API Query and Data Proccessing Functions 

I created the following functions to query and process data from the [Pokemon API](https://pokeapi.co/) using [Pokemon API Documentation](https://pokeapi.co/docs/v2).  

### Pokemon Endpoint Functions.  

Most data relevant to individual pokemon is obtained from the [Pokemon endpoint](https://pokeapi.co/docs/v2#pokemon).  This endpoint returns a complex list of lists with more data than most users would need.  I've provided three functions to query and process pokemon endpoint data.  The functions all return data frames.  

1. `getPokeNameIDFunction`  In order to query individual pokemon, the user must provide either a name or id value.  This function returns a list of all possible pokemon for this endpoint so that the user will know what pokemon are available.  The names can be sorted as an option.


```{r getPokeNameIDFunction}
getPokeNameID <- function(sortName=FALSE){
  
  apiData<-fromJSON("https://pokeapi.co/api/v2/pokemon/?limit=1222")
  
  allNames<-as_tibble(apiData$results)
  
  allNames<-allNames %>% mutate(ID=as.numeric(basename(url)))
  
  if (sortName) {
    allNames<-allNames %>% arrange(name)
  }
  
  return(allNames)
  
}
```


Example `getPokeNameIDFunction` usage with output.  

```{r getPokeNameIDExample}
head(getPokeNameID(sortName = TRUE))
```


2. `getOnePokeData`  Given a pokemon name or id, this function returns a data frame with data for that pokemon.  Given how much data is available and the complexity of processing data, I give the user a few options for the amount of data returned.  The default option returns top level data including `species,height,weight,base_experience`.  Turning the basestat function additionally returns `hp,attack,defense,special_attack,special_defense ,speed`.  Finally, turning the type option on additionally returns primary and secondary types `type_one,type_two`.   



```{r getOnePokeData Function}

getOnePokeData<-function(pokemon,basestat=FALSE,type=FALSE){
  
  ##Get list of pokemon and process user pokemon input
  pokeNameID<-getPokeNameID()
  
  if (is.numeric(pokemon)){
    pokeNameID<-pokeNameID%>%filter(ID==pokemon)
  } else if (is.character(pokemon)){
    pokeNameID<-pokeNameID%>%filter(name==tolower(pokemon))
  } else {
    stop("Please enter either pokemon integer or quoated name value")
  }
  
  PokeList<- fromJSON(pokeNameID$url,flatten = TRUE)
  
  ###Function Default Data
  name<-PokeList$name
  height<-PokeList$height
  id<-PokeList$id
  species<-PokeList$species$name
  weight<-PokeList$weight
  base_experience<-PokeList$base_experience
  
  LocalDF<-data.frame(name,id,species,height,weight,base_experience)
  
  ##process and add base stat data if user selects basestat TRUE
  if (basestat){
    hp<-PokeList$stats$base_stat[1]
    attack<-PokeList$stats$base_stat[2]
    defense<-PokeList$stats$base_stat[3]
    special_attack<-PokeList$stats$base_stat[4]
    special_defense<-PokeList$stats$base_stat[5]
    speed<-PokeList$stats$base_stat[6]
    
    LocalDF<-LocalDF%>%mutate(hp,attack,defense,special_attack   ,special_defense ,speed)
  }
  
  ##process and add type data if user selects type TRUE
  if(type){
    ##All pokemon has at least one type so assign here
    type_one<-PokeList$types$type.name[1]
    
    ##check if more than one type and set 
    ##second type as needed
    if(length(PokeList$types$slot)>1){
      type_two<-PokeList$types$type.name[2]
    }else{
      type_two<-"None"
    }
    
    LocalDF<-LocalDF%>%mutate(type_one,type_two)
  }
  
  
  return(LocalDF)
  
}
```

Examples of ways to use `getOnePokeData`.  

```{r getOnePokeExample, eval=FALSE}
getOnePokeData("Venusaur")
getOnePokeData(pokemon=8,basestat = TRUE)
getOnePokeData(435,type = TRUE)
getOnePokeData(10032,basestat = TRUE,type = TRUE)
```


3. `getEveryPokeData`  This function returns data for ALL pokemon and returns one data frame.  The amount of data returned is dependent on the basetat and type options as described in `getOnePokeData`.  


```{r getEveryPokeData Function}
getEveryPokeData<-function(basestat=FALSE,type=FALSE){
  
  ###Get current number of pokemon to process
  #getPokeNameID
  pokeNameID<-getPokeNameID()
  idVals<-pokeNameID$ID
  
  ###Loop through every pokemon and build data frame
  ###by adding new rows
  ###Most of the time spent here is in the numerous 
  ###   calls to API address since there are so many pokemon
  allPoke<-data.frame()
  for (i in idVals) {
    allPoke<-rbind(allPoke,getOnePokeData(i,basestat,type))
  }
  
  return(allPoke)
}

```
Example of `getEveryPokeData` data frame data.  
```{r getEveryPokeData output,cache=TRUE}
everyPoke<-getEveryPokeData(basestat = TRUE,type = TRUE)
head(everyPoke)
```


### Species Endpoint Functions  

Most pokemon species map to one individual pokemon but there are some species that map to several indidual pokemon.  Collective species data is obtained from the [Pokemon Species endpoint](https://pokeapi.co/docs/v2#pokemon-species).  Because species data is less complex, I was able to return more default data from this endpoint than the pokemon endpoint.  I've provided three functions to query and process pokemon endpoint data.  The functions all return data frames.  


1. `getSpeciesNameID`  This function returns a data frame with a list of possible species names and id values so that the user will know what is available.  Optional sorting my name is provided.  

```{r getSpeciesNameID Function}
getSpeciesNameID <- function(sortName=FALSE){
  
  apiData<-fromJSON("https://pokeapi.co/api/v2/pokemon-species/?limit=1222")
  
  allNames<-as_tibble(apiData$results)
  
  allNames<-allNames %>% mutate(ID=as.numeric(basename(url)))
  
  if (sortName) {
    allNames<-allNames %>% arrange(name)
  }
  
  return(allNames)
  
}
```

2. `getOneSpeciesData`  Given species name or id this function returns a data frame for one species with the following data. `species,shape,generation,base_happiness,capture_rate,gender_rate,hatch_counter,is_baby,is_legendary,is_mythical`.  


```{r getOneSpeciesData Function}
getOneSpeciesData<-function(species){
   
   ##Get list of species and process user species input
   pokeSpeciesID<-getSpeciesNameID()
   
   if (is.numeric(species)){
     pokeSpeciesID<-pokeSpeciesID%>%filter(ID==species)
   } else if (is.character(species)){
     pokeSpeciesID<-pokeSpeciesID%>%filter(name==tolower(species))
   } else {
     stop("Please enter either species integer or quoated name value")
   }
   
   PokeList<- fromJSON(pokeSpeciesID$url,flatten = TRUE)
   
   ###Function Data to return
   species<-PokeList$name
   shape<-PokeList$shape$name
   generation<-PokeList$generation$name
   base_happiness<-PokeList$base_happiness
   capture_rate<-PokeList$capture_rate
   gender_rate<-PokeList$gender_rate
   hatch_counter<-PokeList$hatch_counter
   is_baby<-PokeList$is_baby
   is_legendary<-PokeList$is_legendary
   is_mythical<-PokeList$is_mythical

   
   LocalDF<-data.frame(species,shape,generation,base_happiness,  
            capture_rate,gender_rate,hatch_counter,  
            is_baby,is_legendary,is_mythical)
   

   
   return(LocalDF)
   
 }
 
```

3. `getEverySpeciesData`  This function returns data for every species as a data frame with optional sorting of the data based on the sortName option.  The following data is returned  
`species,shape,generation,base_happiness,capture_rate,gender_rate,hatch_counter,is_baby,is_legendary,is_mythical`.  

```{r getEverySpeciesData Function}
getEverySpeciesData<-function(sortName=FALSE){
   
   ###Get current number of species to process
   pokeSpeciesID<-getSpeciesNameID()
   idVals<-pokeSpeciesID$ID
   
   
   ###Loop through every species and build data frame
   ###by adding new rows
   ###Most of the time spent here is in the numerous 
   ###   calls to API address since there are so many species
   allPoke<-data.frame()
   for (i in idVals) {
     allPoke<-rbind(allPoke,getOneSpeciesData(i))
   }
   
   if (sortName) {
     allPoke<-allPoke %>% arrange(species)
   }
   
   return(allPoke)
 }
```

Example of `getEverySpeciesData` data frame data.  
```{r getEverySpeciesData output,cache=TRUE}
everyPokeSpecies<-getEverySpeciesData(sortName = TRUE)
head(everyPokeSpecies)
```


### Evolution Chain Endpoint Functions.  

Many pokemon can [evolve](https://pokemondb.net/evolution) into another more powerful pokemon.  Evolution chain data is obtained from the [Pokemon Evolution Chain Endpoint](https://pokeapi.co/docs/v2#evolution-chains).  This endpoint only takes ID and those IDs are linked to one part of a chain.

I've provided two functions to query and process pokemon evolution chain endpoint data.  The functions both return data frames.  



1. `getOneEvolveData`  

```{r getOneEvolveData Function}
getOneEvolveData<-function(ID){
  
  ###Construct URL from the given ID and call API
  basicURL<-"https://pokeapi.co/api/v2/evolution-chain/"
  queryURL<-paste0(basicURL,ID)
  queryResult<-fromJSON(queryURL)
  
  ###Parse results into stages or no evolve categories
  stageOne<-queryResult$chain$species$name
  stageTwo<-queryResult[["chain"]][["evolves_to"]][["species"]][["name"]]
  stageThree<-queryResult[["chain"]][["evolves_to"]][["evolves_to"]][[1]][["species"]][["name"]] 
  if (is.null(stageTwo)){
    stageTwo<-"None"
  }
  if (is.null(stageThree)){
    stageThree<-"None"
  }
  
  localDF<-data.frame(stageOne,stageTwo,stageThree)
  return(localDF)
}


```


```{r getOneEvolveData Example}
  getOneEvolveData(57)
```



2. `getAllEvolveSeries`  

```{r getAllEvolveSeries Function, cache=TRUE}
getAllEvolveSeries<-function(sortName=FALSE){
  
  metaEvolve<-fromJSON("https://pokeapi.co/api/v2/evolution-chain/?limit=600")
  
  metaEvolveDF<-as_tibble(metaEvolve$results)
  
  metaEvolveDF<-metaEvolveDF %>% mutate(ID=as.numeric(basename(url)))
  
  allEvolve<-data.frame()
  for (loopID in metaEvolveDF$ID) {
    allEvolve<-rbind(allEvolve,getOneEvolveData(loopID))
  } 
  
   if (sortName) {
     allEvolve<-allEvolve %>% arrange(stageOne)
   }
  
  return(allEvolve)
}

resultsEvolve<-getAllEvolveSeries(sortName = TRUE)
head(resultsEvolve)

```



3. `getAllEvolveStages`  

```{r getAllEvolveStages Function}

getAllEvolveStages<-function(sortName=FALSE){
  
  resultsEvolve<-getAllEvolveSeries()
  
  ###Handles the first one which they all have
  ###Now can do stageTwo and three
  allEvolve<-data.frame()
  species<-resultsEvolve$stageOne
  stages<-ifelse(resultsEvolve$stageTwo=="None",stage<-"noEvolve",stage<-"one")
  stages
  allEvolve<-data.frame(species,stages)
  ###Need to use rbind to add other parts after this part
  species<-resultsEvolve$stageTwo
  stages<-ifelse(resultsEvolve$stageTwo=="None",stage<-"noEvolve",stage<-"two")
  twoEvolve<-data.frame(species,stages)
  twoEvolve<-twoEvolve %>% filter(species!="None")
  allEvolve<-rbind(allEvolve,twoEvolve)
  
  species<-resultsEvolve$stageThree
  stages<-ifelse(resultsEvolve$stageThree=="None",stage<-"noEvolve",stage<-"three")
  threeEvolve<-data.frame(species,stages)
  threeEvolve<-threeEvolve %>% filter(species!="None")
  allEvolve<-rbind(allEvolve,threeEvolve)
  ###Later use distinct function to remove duplicate rows
  allEvolve<-allEvolve %>% distinct(species,.keep_all = TRUE)
  
  allEvolve$stages<-as.factor(allEvolve$stages)
  allEvolve$stages<-ordered(allEvolve$stages,levels=c("one","two","three","noEvolve"))
  
  if (sortName) {
     allEvolve<-allEvolve %>% arrange(species)
   }
  
  return(allEvolve)
}


```


```{r getAllEvolveStages Example}
  evolveStages<-getAllEvolveStages(sortName = TRUE)
  head(evolveStages)
```



## Exploring Data



```{r getData, cache=TRUE}
allPoke<-getEveryPokeData(basestat = TRUE,type = TRUE)
allSpecies<-getEverySpeciesData()
```


```{r contingencytables}
#table(allPoke$type_one,allPoke$species)
#allPoke %>% distinct()
#inner_join(allPoke,evolveStages,by="species") %>% select(name,stages,everything())

combinePoke<-inner_join(allPoke,evolveStages,by="species") %>% select(name,stages,everything())

tOne<-table(combinePoke$stages,combinePoke$type_one )
tOne<-table(combinePoke$type_one,combinePoke$stages )
kable(addmargins(tOne),caption = "Contingency Table of Type by Stage")

```


```{r plotheightweight}
head(allPoke)
g<-ggplot(data = allPoke,aes(x=weight,y=height))
g+geom_point(aes(color=type_one))

```

```{r summarystats}
allPoke %>% group_by(type_one) %>% summarise(mweight=mean(weight),sdweight=sd(weight))
allPoke %>% summary()
summary(allPoke$weight)
cor(allPoke$hp,allPoke$weight)
cor(allPoke$height,allPoke$weight)
shortPoke<-allPoke %>% filter(height<500) 
cor(shortPoke$height,shortPoke$weight)

summary(shortPoke$height)

g<-ggplot(data = shortPoke,aes(x=weight,y=height))
g+geom_point(aes(color=type_one))

```


